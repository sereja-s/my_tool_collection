// JavaScript может использоваться в браузере, на веб-сервере или в какой-то другой среде, даже в кофеварке. Каждая
// среда предоставляет свою функциональность, которую спецификация JavaScript называет окружением

// Окружение предоставляет свои объекты и дополнительные функции, в дополнение базовым языковым

// Ниже в общих чертах показано, что доступно для JavaScript в браузерном окружении:

//                                    window
// DOM                                   BOM                                     JavaScript
// -document                          -navigator                                 -Object
//   ...                               -screen                                    -Array
//                                    -location                                  -Function
//                                    -frames                                       ...
//                                    -history
//                                    -XMLHttpRequest

// Как мы видим, имеется корневой объект window, который выступает в 2 ролях:

// -Во-первых, это глобальный объект для JavaScript-кода, об этом более подробно говорится в главе Глобальный объект.
// -Во-вторых, он также представляет собой окно браузера и располагает методами для управления им

// DOM (Document Object Model)

// Document Object Model, сокращённо DOM – объектная модель документа, которая представляет все содержимое страницы в
// виде объектов, которые можно менять.

// Объект document – основная «входная точка». С его помощью мы можем что-то создавать или менять на странице

//-----------------------------------------------------------------------------------------------------------------//

// BOM (Browser Object Model)

// Объектная модель браузера (Browser Object Model, BOM) – это дополнительные объекты, предоставляемые браузером (окружением), чтобы работать со всем, кроме документа.

// Например:
// -Объект navigator даёт информацию о самом браузере и операционной системе. Среди множества его свойств самыми
// известными являются: navigator.userAgent – информация о текущем браузере, и navigator.platform – информация о
// платформе (может помочь в понимании того, в какой ОС открыт браузер – Windows/Linux/Mac и так далее).
// -Объект location позволяет получить текущий URL и перенаправить браузер по новому адресу.
// Вот как мы можем использовать объект location:

/*
alert(location.href); // показывает текущий URL
if (confirm("Перейти на Wikipedia?")) {
	location.href = "https://wikipedia.org"; // перенаправляет браузер на другой URL
}
 */

// Функции alert/confirm/prompt тоже являются частью BOM: они не относятся непосредственно к странице, но представляют
// собой методы объекта окна браузера для коммуникации с пользователем

//--------------------------------------------------------------------------------------------------------------------//

// DOM-дерево

// Основой HTML-документа являются теги.

// В соответствии с объектной моделью документа («Document Object Model», коротко DOM), каждый HTML-тег является
// объектом. Вложенные теги являются «детьми» родительского элемента. Текст, который находится внутри тега, также является объектом.

// Все эти объекты доступны при помощи JavaScript, мы можем использовать их для изменения страницы

// Теги являются узлами-элементами (или просто элементами). Они образуют структуру дерева: <html> – это корневой узел, <head> и <body> его дочерние узлы и т.д.
// Текст внутри элементов образует текстовые узлы, обозначенные как #text. Текстовый узел содержит в себе только строку
// текста. У него не может быть потомков, т.е. он находится всегда на самом нижнем


// Автоисправление

// Если браузер сталкивается с некорректно написанным HTML-кодом, он автоматически корректирует его при построении DOM



// Все, что есть в HTML, даже комментарии, является частью DOM.

// Даже директива <!DOCTYPE...>, которую мы ставим в начале HTML, тоже является DOM-узлом. Она находится в дереве DOM
// прямо перед <html>. Мы не будем рассматривать этот узел, мы даже не рисуем его на наших диаграммах, но он существует.

// Даже объект document, представляющий весь документ, формально является DOM-узлом.

// Существует 12 типов узлов. Но на практике мы в основном работаем с 4 из них:
// -document – «входная точка» в DOM.
// -узлы-элементы – HTML-теги, основные строительные блоки.
// -текстовые узлы – содержат текст.
// -комментарии – иногда в них можно включить информацию, которая не будет показана, но доступна в DOM для чтения JS


//===================================================================================================================//

// Навигация по DOM-элементам

//DOM позволяет нам делать что угодно с элементами и их содержимым, но для начала нужно получить соответствующий DOM-объект.

// Все операции с DOM начинаются с объекта document. Это главная «точка входа» в DOM. Из него мы можем получить доступ к любому узлу.

// Так выглядят основные ссылки, по которым можно переходить между узлами DOM:

//                             document

//                 document.documentElement < HTML >

//	                         document.body
//                         (if inside body)
//------------------------------------------------------------------//

//                             parentNode

// previousSibling               < DIV >               nextSibling

//                              childNodes

//                   firstChild            lastChild

// Поговорим об этом подробнее.

// Сверху: documentElement и body

// Самые верхние элементы дерева доступны как свойства объекта document: <html> = document.documentElement
// (Самый верхний узел документа: document.documentElement. В DOM он соответствует тегу <html>)

// получим объект html со всем его содержимым:
const htmlElement = document.documentElement;

// <body> = document.body
// Другой часто используемый DOM-узел – узел тега <body>: document.body.

// получим объект body со всем его содержимым:
const bodyElement1 = document.body;

// <head> = document.head
// Тег <head> доступен как document.head

// получим объект body со всем его содержимым:
const headElement = document.head;

console.log(htmlElement);
console.log(bodyElement1);
console.log(headElement);

//-------------------------------------------------------------------------------------------------------------------//

// Дети: childNodes, firstChild, lastChild

// Здесь и далее мы будем использовать два принципиально разных термина:

// 1) Дочерние узлы (или дети) – элементы, которые являются непосредственными детьми узла. Другими словами, элементы,
// которые лежат непосредственно внутри данного. Например, <head> и <body> являются детьми элемента <html>.

// 2) Потомки – все элементы, которые лежат внутри данного, включая детей, их детей и т.д.


// - Свойства firstChild и lastChild обеспечивают быстрый доступ к первому и последнему дочернему элементу


// Получив объект: body в константу, мы можем использовать этот объект как отправную точку для последующей навигации:
// 1) получаем объект: body
const bodyElement = document.body;

// 2) получаем доступ к первому и последнему дочернему элементу(узлу) объекта:
const firstChildNode = bodyElement.firstChild;
const lastChildNode = bodyElement.lastChild;

console.log(firstChildNode);
console.log(lastChildNode);

// - Коллекция childNodes содержит список всех детей, включая текстовые узлы:
const childNodes = bodyElement.childNodes;

console.log(childNodes); // NodeList(14) [text, comment, text, h1, text, comment, text, h2, text, div.lesson, text, h4#text, text, script]


// Для проверки наличия дочерних узлов существует также специальная функция hasChildNodes():
// выведем результат её работы для объекта:
console.log(bodyElement.hasChildNodes()); // true

//------------------------------------------------------------------------------------------------------------------//

// DOM-коллекции

// Как мы уже видели, childNodes похож на массив. На самом деле это не массив, а коллекция – особый перебираемый объект-псевдомассив.

// И есть два важных следствия из этого:

// - Для перебора коллекции мы можем использовать for..of:
for (let node of document.body.childNodes) {

	console.log(node); // покажет все узлы из коллекции
}
// Это работает, потому что коллекция является перебираемым объектом (есть требуемый для этого метод Symbol.iterator).

// - Методы массивов не будут работать, потому что коллекция – это не массив:
console.log(document.body.childNodes.filter); // undefined (у коллекции нет метода filter!)

// Первый пункт – это хорошо для нас. Второй – бывает неудобен Если нам хочется использовать именно методы массива, то
// мы можем создать настоящий массив из коллекции, используя Array.from:
console.log(Array.from(document.body.childNodes).filter); // сделали массив

// Особенности DOM-коллекции:

// 1) DOM-коллекции – только для чтения
// DOM-коллекции, и даже более – все навигационные свойства, перечисленные в этой главе, доступны только для чтения. Мы
// не можем заменить один дочерний узел на другой, просто написав childNodes[i] = ....
// (Для изменения DOM требуются другие методы. Мы увидим их в следующей главе)

// 2) DOM-коллекции живые
// Почти все DOM-коллекции, за небольшим исключением, живые. Другими словами, они отражают текущее состояние DOM.
// (Если мы сохраним ссылку на elem.childNodes и добавим/удалим узлы в DOM, то они появятся в сохранённой коллекции автоматически)

// 3) Не используйте цикл for..in для перебора коллекций
// Коллекции перебираются циклом for..of. Некоторые начинающие разработчики пытаются использовать для этого цикл for..in.
// Не делайте так. Цикл for..in перебирает все перечисляемые свойства. А у коллекций есть некоторые «лишние», редко используемые свойства, которые обычно нам не нужны

//-------------------------------------------------------------------------------------------------------------------//

// Соседи и родитель

// Соседи – это узлы, у которых один и тот же родитель.

//Например, здесь <head> и <body> соседи:
/*
<html>
	<head>...</head>
	<body>...</body>
</html>
*/
// говорят, что <body> – «следующий» или «правый» сосед <head>, также можно сказать, что <head> «предыдущий» или «левый» сосед <body>.

// Следующий узел того же родителя(следующий сосед) – в свойстве nextSibling, а предыдущий – в previousSibling.
// Родитель доступен через parentNode

// получим предыдущий узел объекта: body
const previousSiblingNode = bodyElement.previousSibling;
console.log(previousSiblingNode); // #text (текстовый узел, которого не видно в DOM-дереве (например перевод строки, пробел и т.д.))

// получим следующий узел объекта: body 
const nextSiblingNode = bodyElement.nextSibling;
console.log(nextSiblingNode); // null (т.к. после body ничего нет (т.е. мы обращаемся к несуществующему объекту(узлу)))

// получим родителя объекта: body
const parentNode = bodyElement.parentNode;
console.log(parentNode); // получим объект: html со всем содержимым

//===================================================================================================================//

// Навигация только по элементам (тегам, которые формируют структуру страницы)

// Навигационные свойства, описанные выше, относятся ко всем узлам в документе. В частности, в childNodes находятся и
// текстовые узлы и узлы-элементы и узлы-комментарии, если они есть.

console.log(childNodes); // NodeList(14) [text, comment, text, h1, text, comment, text, h2, text, div.lesson, text, h4#text, text, script]

// Но для большинства задач текстовые узлы и узлы-комментарии нам не нужны. Мы хотим манипулировать узлами-элементами,
// которые представляют собой теги и формируют структуру страницы.

const bodyChildren = bodyElement.children;
console.log(bodyChildren); // HTMLCollection(5) [h1, h2, div.lesson, h4#text, script, text: h4#text]

//Поэтому давайте рассмотрим дополнительный набор ссылок, которые учитывают только узлы-элементы:

//                 document.documentElement < HTML >

//	                         document.body
//                         (if inside body)
//------------------------------------------------------------------//

//                             parentElement

// previousElementSibling         < DIV >          nextElementSibling

//                               children

//             firstElementChild           lastElementChild

// Эти ссылки похожи на те, что раньше, только в ряде мест стоит слово Element:
// - children – коллекция детей, которые являются элементами.
// - firstElementChild, lastElementChild – первый и последний дочерний элемент.
// - previousElementSibling, nextElementSibling – соседи-элементы.
// - parentElement – родитель-элемент

// получим первый элемент объекта: body
const firstChild = bodyElement.firstElementChild;
console.log(firstChild); // тег h1

// получим последний элемент объекта: body 
const lastChild = bodyElement.lastElementChild;
console.log(lastChild); // тег script


// получим соседние и родительские элементы объекта: body

// получим предыдущий элемент объекта: body
const previousSibling = bodyElement.previousElementSibling;
console.log(previousSibling); // тег head

// получим следующий элемент объекта: body 
const nextSibling = bodyElement.nextElementSibling;
console.log(nextSibling); // null (т.к. после закрывающего тега: body ничего нет)

// получим родителя объекта: body
const parentElement = bodyElement.parentElement;
console.log(parentElement); // получим объект: html со своим содержимым

//====================================================================================================================//

// Поиск произвольного элемента страницы

// Свойства навигации по DOM хороши, когда элементы расположены рядом. А что, если нет? Как получить произвольный
// элемент страницы? Для этого в DOM есть дополнительные методы поиска.


// querySelectorAll

// Самый универсальный метод поиска – это elem.querySelectorAll(css), он возвращает все элементы внутри elem, удовлетворяющие данному CSS-селектору в виде статичной коллекции:

// Поиск по селектору класса (перед указанием имени класса необходимо поставить точку):
const elementsOne = document.querySelectorAll('.lesson__list');
console.log(elementsOne); // коллекция всех найденных объектов (здесь- один объект): NodeList [ul.lesson__list]

// Поиск по селектору тега:
const elementsTwo = document.querySelectorAll('li');
console.log(elementsTwo); // коллекция всех найденных объектов c искомым тегом

// Поиск по смешанному селектору тега и класса:
const elementsThree = document.querySelectorAll('li.lesson__item-sub-list');
console.log(elementsThree);

// Поиск по тегу первого уровня вложенности:
const elementsFour = document.querySelectorAll('.lesson__list>li');
console.log(elementsFour);

// Поиск по нескольким классам (ставим точку перед названием кдасса, между классами - запятую):
const elementsFive = document.querySelectorAll('.lesson__list, .lesson__text');
console.log(elementsFive);

// Поиск по вложенным классам (запятая не ставится):
const elementsSix = document.querySelectorAll('.lesson__text .lesson__list'); // здесь ищем все объекты с классом: lesson__list, котрорые находятся внутри класса lesson__text
console.log(elementsSix);

// Поиск по id(должен быть уникальным):
const elementsSeven = document.querySelectorAll('#listItem');
console.log(elementsSeven); // получим единственный элемент, расположенный в теге, которому присвоен искомый id

// Поиск по атрибуту:
const elementsEight = document.querySelectorAll('[data-item]');
console.log(elementsEight); // получим все элементы, расположенные в тегах, которым присвоен искомый атрибут

// Поиск по атрибуту со значением:
const elementsNine = document.querySelectorAll('[data-item="85"]');
console.log(elementsNine);


// Т.к. querySelectorAll вернёт коллекцию (статичную) из искомых элементов, то мы можем получить из неё конкретный объект, указав его ключ:
console.log(elementsFour[1]); // получим в консоли 2-ой li на странице: <li id="listItem" class="lesson__item-list">Пункт №2</li>

// Ещё коллекцию можно перебрать:
for (const item of elementsFour) {

	console.log(item); // выведем в консоль все записи коллекции из переменной
}

// Хоть статичная колекция не массив, можно использовать метод перебора:forEach
elementsFour.forEach(element => {

	console.log(element); // результат будет аналогичным предыдущему перебору
});

//-------------------------------------------------------------------------------------------------------------------//

// Искать можно не только в объекте: document

// например:
// сначала в константу получим у объекта: document, коллекцию объктов у которых есть искомый класс:
const subList = document.querySelectorAll('.lesson__sub-list');
console.log(subList); // NodeList [ul.lesson__sub-list]

// далее хотим искать теги li, только внутри этого объекта (при обращении к объекту укажем конкретно позицию [0], хотя в нашем случае в константе: subList лежит коллекция всего из одного элемента (объекта)):
const subItem = subList[0].querySelectorAll('li');
console.log(subItem); // NodeList(4) [li.lesson__item-sub-list, li.lesson__item-sub-list, li.lesson__item-sub-list, li.lesson__item-sub-list]

//===================================================================================================================//

// querySelector

// Метод elem.querySelector(css) возвращает первый элемент, соответствующий данному CSS-селектору (т.е. вернёт один объект)

// Иначе говоря, результат такой же, как при вызове elem.querySelectorAll(css)[0], но он сначала найдёт все элементы, а
// потом возьмёт первый, в то время как elem.querySelector найдёт только первый и остановится. Это быстрее, кроме того, его короче писать

//====================================================================================================================//

// document.getElementById

// Если у элемента есть атрибут id, то мы можем получить его вызовом document.getElementById(id), где бы он ни находился
// При этом:
// - значение id должно быть уникальным
// - Метод getElementById можно вызвать только для объекта document. Он осуществляет поиск по id по всему документу
const elem = document.getElementById('listItem');
console.log(elem); // <li id="listItem" class="lesson__item-list">Пункт №2</li>

//--------------------------------------------------------------------------------------------------------------------//

// getElementsBy* (Не забываем про букву "s"!, т.к. возвращается не один элемент, а коллекция (список элементов))


// Существуют также другие методы поиска элементов по тегу, классу и так далее. На данный момент, они скорее исторические, так как querySelector более чем эффективен. Здесь мы рассмотрим их для полноты картины, также вы можете встретить их в старом коде:

// elem.getElementsByTagName(tag) - ищет элементы (как в объекте: document, так и в любом другом объекте) с данным тегом
// и возвращает их "живую" коллекцию (Передав "*" вместо тега, можно получить всех потомков)
const el = document.getElementsByTagName('li');
console.log(el); // HTMLCollection(7), т.е. "живая" HTML-коллекция

// elem.getElementsByClassName(className) - возвращает элементы, которые имеют данный CSS - класс.
const el2 = document.getElementsByClassName('lesson__item-sub-list');
console.log(el2); // HTMLCollection(4), т.е. "живая" HTML-коллекция

//  document.getElementsByName(name) - ищет элементы (в объекте: document) с заданным атрибутом name и возвращает их. Очень редко используется
const el3 = document.getElementsByName('list');
console.log(el3); // NodeList [ul.lesson__list] - «Живой» NodeList-коллекция

//+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++=//

// Примечание:

// HTMLCollection и NodeList — это очень похожие на массив коллекции. Они хранят элементы веб-страницы (узлы DOM).
// NodeList может хранить любые типы узлов, а HTMLCollection — только узлы HTML элементов. К элементам коллекций можно
// обращаться по индексу, но у них нет привычных методов массива:

// 1) HTMLCollection возвращают методы getElementsByTagName() и getElementsByClassName()
// Полученная один раз коллекция всегда остаётся актуальной — JavaScript будет обновлять её в случае, если на странице
// появляется подходящий элемент. Поэтому HTMLCollection называют «живой» коллекцией

// 2) NodeList работает почти так же, как и HTMLCollection.
// Разница:
// - NodeList может хранить любые типы узлов, например текстовые узлы и комментарии, а HTMLCollection — только узлы HTML элементов;
// - HTMLCollection позволяет обращаться к элементам не только по индексу, но и по имени с помощью метода namedItem();
// - NodeList может быть не только «живой» коллекцией, но и статической.Такая коллекция не обновляется при появлении на странице новых элементов.

// «Живой» NodeList возвращают метод getElementsByName() и свойство childNodes.
// Статический NodeList возвращает метод querySelectorAll()

// посмотрим на примере:

// Получаем статическую коллекцию:
const listStatic = document.querySelectorAll('.lesson__item-list');
console.log(listStatic); // NodeList(3)

// Получаем "живую" коллекцию :
const listLive = document.getElementsByClassName('lesson__item-list');
console.log(listLive); // HTMLCollection(3)

// Используем один из методов изменения HTML-документа и создадим новый HTML-объект:
const lessonList = document.querySelector('.lesson__list');
lessonList.insertAdjacentHTML(
	"beforeend",
	'<li class="lesson__item-list lesson__item-list-blue">Новый пункт-blue(добавлен в script.js:455)</li>'
);

// теперь выведем теже колекции:
console.log(listStatic); // NodeList(3)
console.log(listLive); // HTMLCollection(4) - здесь динамически добавился ещё один объект

//===================================================================================================================//

// Дополнительные методы поиска:

// closest (этот метод часто используется для проверки на существование того или иного родителя. А также для изменения родителя определённого, конкретного объекта)

// Предки элемента – родитель, родитель родителя, его родитель и так далее. Вместе они образуют цепочку иерархии от элемента до вершины.

// Метод elem.closest(css) ищет ближайшего предка, который соответствует CSS-селектору, поданного на вход, в качестве
// параметра. Сам элемент также включается в поиск.
// (Другими словами, метод closest поднимается вверх от элемента и проверяет каждого из родителей. Если он соответствует
// селектору, поиск прекращается. Метод возвращает либо предка, либо null, если такой элемент не найден)

// в константу: elemClo получаем объект с классом: lesson__item-sub-list
const elemClo = document.querySelector('.lesson__item-sub-list');

// в константу:  хотим получить родителя этого объекта с классом: lesson__list
const parentList = elemClo.closest('.lesson__list');
console.log(parentList); // <ul name="list" class="lesson__list">...</ul>


// Напоминаем: parentElement возвращает только непосредственного родителя элемента

//====================================================================================================================//

// matches

// Предыдущие методы искали по DOM.

// Метод elem.matches(css) ничего не ищет, а проверяет, удовлетворяет ли elem CSS-селектору, и возвращает true или false.

// Этот метод удобен, когда мы перебираем элементы (например, в массиве или в чём-то подобном) и пытаемся выбрать те из них, которые нас интересуют

// пример:
// получим коллекцию объктов c указанным классом:
const elemMatch = document.querySelectorAll('.lesson__item-list');

// с помощью цикла перебираем полученную коллекцию и определяем если в содержащихся в ней элементах, класс с определёным
// модификатором Если да, то выводим в консоль соответствующую строку:
for (let elem of elemMatch) {

	if (elem.matches('[class$=lesson__item-list-red]')) {

		console.log('Красный');
	} else if (elem.matches('[class$=lesson__item-list-blue]')) {

		console.log('Синий');
	}
}

//--------------------------------------------------------------------------------------------------------------------//

// И, напоследок, давайте упомянем ещё один метод, который проверяет наличие отношений между предком и потомком:
// elemA.contains(elemB) вернёт true, если elemB находится внутри elemA (elemB потомок elemA) или когда elemA==elemB

//====================================================================================================================//

// Стоит добавить, что получив объект тем или иным способом, мы можем применитьсвойства навигации о которых говорили ранее
// например
// получаем в константу объект:
const text = document.querySelector('.lesson__text');

// затем получим следующий за ним объект:
const list = text.nextElementSibling;
console.log(list); // <ul name="list" class="lesson__list">...</ul>

//=====================================================================================================================//

// Изменение документа:

// innerHTML: содержимое элемента

// Свойство innerHTML позволяет получить HTML - содержимое элемента в виде строки. Мы также можем изменять его. Это один из самых мощных способов менять содержимое на странице

// Получаем объект:
const textEl = document.querySelector('.lesson__text');

// получем содержимое объекта в виде строки (вместе с html):
const textElContent = textEl.innerHTML;
console.log(textElContent); // строка: Текст <span class="yellow">здесь будет изменён</span>

// перезаписываем содержимое объекта:
textEl.innerHTML = 'Текст с внесёнными изменениями'
console.log(textEl.innerHTML); // строка: console.log(textEl.innerHTML);

// дописываем содержимое объекта
textEl.innerHTML = `<p>${textElContent}</p> <p>Текст с <span class="yellow">внесёнными</span> изменениями </p>`;
console.log(textEl.innerHTML); // строка: <p>Текст <span class="yellow">здесь будет изменён</span></p> <p>Текст с <span class="yellow">внесёнными</span> изменениями </p>

//-------------------------------------------------------------------------------------------------------------------//

// Скрипты не выполнятся
// Если innerHTML вставляет в документ тег <script> – он становится частью HTML, но не запускается

//====================================================================================================================//

// outerHTML: HTML элемента целиком

// Свойство outerHTML содержит HTML элемента целиком. Это как innerHTML(содеримое) плюс сам элемент(оболочка)

// (Будьте внимательны: в отличие от innerHTML, запись в outerHTML не изменяет элемент. Вместо этого элемент заменяется
// целиком во внешнем контексте(в html-коде и соответственно отображении на странице)), т.е. появляется новый элемент
// вместо того который был (при этом остаётся доступ к старому элементу, т.к. он не изменился, а просто был заменён новым)

// Получаем объект:
const textElOut = document.querySelector('.lesson__text');

// получем содержимое объекта в виде строки (вместе с html):
const textElContentOut = textElOut.outerHTML;
console.log(textElContentOut); // строка (облочка с содержимым):
// <div class="lesson__text"><p>Текст <span class="yellow">здесь будет изменён</span></p> <p>Текст с <span class="yellow">внесёнными</span> изменениями </p></div>

// попробуем перезаписыть содержимое объекта:
//textElOut.outerHTML = '<span class="yellow">Опять просто текст >>></span>' // на странице текст изменится, но если захотим теперь получить содержимое объекта:
//console.log(textElOut.outerHTML); // увидим, что содержимое не изменилось, т.е. тоже, что было в строке: 567

//====================================================================================================================//

// textContent: просто текст

// Свойство textContent предоставляет доступ к тексту внутри элемента за вычетом всех <тегов>

// Получаем объект:
const textElemCont = document.querySelector('.lesson__text');
console.log(textElemCont);

// получим доступ к тексту внутри объекта(элемента):
const textCont = textElemCont.textContent;
console.log(textCont); // строка (без тегов): Текст здесь будет изменён Текст с внесёнными изменениями

// полезная возможность: записывать текст с обращением к свойству: textContent, т.к. позволяет писать текст «безопасным способом».

// Представим, что у нас есть произвольная строка, введённая пользователем, и мы хотим показать её.

// - С innerHTML вставка происходит «как HTML», со всеми HTML-тегами.
// - С textContent вставка получается «как текст», все символы трактуются буквально

// textElemCont.textContent = '<span class="yellow">Мне нравится программирование</span>';
// console.log(textElemCont.textContent); // строка «как текст», все символы трактуются буквально:
// <span class="yellow">Мне нравится программирование</span>

//=====================================================================================================================//

// nodeValue/data: содержимое текстового узла

// Свойство innerHTML есть только у узлов-элементов.

// У других типов узлов, в частности, у текстовых, есть свои аналоги: свойства nodeValue и data. Эти свойства очень похожи при использовании, есть лишь небольшие различия в спецификации. Мы будем использовать data, потому что оно короче

// получаем объект
const textElement = document.querySelector('.lesson__text');

// получаем следующий узел
const getComment = textElement.nextSibling;
console.log(getComment); // <!-- комментарий --> (при этом комментарий должен располагаться в одной строке с объектом(межу ними не допускается других символов))

// получим текст комментария:
console.log(getComment.data); //  комментарий

// изменим комментарий:
getComment.data = 'Привет';
console.log(getComment.data); // Привет

//==================================================================================================================//

// Создание элемента

// DOM-узел можно создать двумя методами:

// 1) document.createElement(tag)- Создаёт новый элемент с заданным тегом:
let newElement = document.createElement('div');
console.log(newElement); // <div></div>

// наполним новый элемент контентом
newElement.innerHTML = 'контент <span class="yellow">для</span> нового div (добавлен в script.js:636)';
console.log(newElement);


// 2) document.createTextNode(text) - Создаёт новый текстовый узел с заданным текстом:
let textNode = document.createTextNode('А вот и я');
console.log(textNode); // "А вот и я"


// Мы создали элемент, но пока он только в переменной. Мы не можем видеть его на странице, поскольку он не является частью документа
// Вот методы для различных вариантов вставки:

// node.append(...nodes or strings) – добавляет узлы или строки внутрь в конец node,
// 	node.prepend(...nodes or strings) – вставляет узлы или строки внутрь и в начало node,
// 		node.before(...nodes or strings) – вставляет узлы или строки до node,
// 			node.after(...nodes or strings) – вставляет узлы или строки после node,
// 				node.replaceWith(...nodes or strings) – заменяет node заданными узлами или строками.

textElement.before(newElement); // новый элемент: newElement вставим перед объектом: textElement
textElement.after(newElement); // новый элемент: newElement вставим после объекта: textElement
textElement.prepend(newElement); // новый элемент: newElement вставим внутрь (в начало) объекта: textElement
textElement.append(newElement); // новый элемент: newElement вставим внутрь (в конец) объекта: textElement

// Эти методы могут вставлять несколько узлов и текстовых фрагментов за один вызов
textElement.append(newElement, 'Класс!');

// при этом строки вставляются безопасным способом, как делает это elem.textContent
// пример:
// textElement.append('контент <span class="yellow">для</span> нового div (добавлен в script.js:636)'); // вся строка выводится на страницу как текст

// Поэтому эти методы могут использоваться только для вставки DOM-узлов или текстовых фрагментов.

//===================================================================================================================//

// А что, если мы хотим вставить HTML именно «как html», со всеми тегами и прочим, как делает это elem.innerHTML?

// insertAdjacentHTML/Text/Element

// С этим может помочь другой, довольно универсальный метод: elem.insertAdjacentHTML(where, html).

// Первый параметр – это специальное слово, указывающее, куда по отношению к elem производить вставку. Значение должно быть одним из следующих:
// "beforebegin" – вставить html непосредственно перед elem,
// "afterbegin" – вставить html в начало elem,
// "beforeend" – вставить html в конец elem,
// "afterend" – вставить html непосредственно после elem.
// Второй параметр – это HTML-строка, которая будет вставлена именно «как HTML».
textElement.insertAdjacentHTML('beforebegin', 'вставка<span class="yellow"> HTML </span> (добавлен в script.js:681)');

//-------------------------------------------------------------------------------------------------------------------//

// У метода: insertAdjacentHTML есть два брата:

// 1) elem.insertAdjacentText(where, text) – такой же синтаксис, но строка text вставляется «как текст», вместо HTML,

// 2) elem.insertAdjacentElement(where, elem) – такой же синтаксис, но вставляет элемент elem.

// Они существуют, в основном, чтобы унифицировать синтаксис. На практике часто используется только insertAdjacentHTML.
// Потому что для элементов и текста у нас есть методы append/prepend/before/after – их быстрее написать, и они могут вставлять как узлы, так и текст

//--------------------------------------------------------------------------------------------------------------------//

// Удаление узлов

// Для удаления узла есть методы node.remove().

// Например:

// получим объект
const texth1 = document.querySelector('h1');

// создадим новый элемент
let divAl = document.createElement('div');
// присвоим имя классу нового элемента
divAl.className = "alert";
// наполним новый элемент контентом
divAl.innerHTML = "<span>Всем привет!</span>Вы прочитали важное сообщение.";
console.log(divAl);

// document.body.before(divAl);
// выведем новый элемент после объекта: h1
texth1.after(divAl);
// сделаем так, чтобы наше сообщение(новый элемент) удалялось через 5-ть секунд:
setTimeout(() => divAl.remove(), 5000);

