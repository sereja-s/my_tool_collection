// Строки

// В JavaScript любые текстовые данные являются строками Строку можно создать с помощью одинарных, двойных либо обратных кавычек:

// Кавычки

// В JavaScript есть разные типы кавычек:

let single = 'single-quoted';
let double = "double-quoted";

let backticks = `backticks`;

// Одинарные и двойные кавычки работают, по сути, одинаково, а если использовать обратные кавычки, то в такую строку мы
// сможем вставлять произвольные выражения, обернув их в ${… }:

function sum(a, b) {
	return a + b;
}

console.log(`1 + 2 = ${sum(1, 2)}.`); // 1 + 2 = 3.

// Ещё одно преимущество обратных кавычек — они могут занимать более одной строки, вот так:

let guestList = `Guests:
 * John
 * Pete
 * Mary
`;

console.log(guestList); // список гостей, состоящий из нескольких строк

// Выглядит вполне естественно, не правда ли? Но если попытаться использовать точно так же одинарные или двойные кавычки, то будет ошибка

//====================================================================================================================//

// Спецсимволы

// Многострочные строки также можно создавать с помощью одинарных и двойных кавычек, используя так называемый «символ
// перевода строки», который записывается как \n:
let guestList2 = "Guests:\n * John\n * Pete\n * Mary";

console.log(guestList2); // список гостей, состоящий из нескольких строк

//В частности, эти две строки эквивалентны, просто записаны по-разному:
// перевод строки добавлен с помощью символа перевода строки
let str1 = "Hello\nWorld";

// многострочная строка, созданная с использованием обратных кавычек
let str2 = `Hello
World`;

console.log(str1 == str2); // true

// Есть и другие, реже используемые спецсимволы. Вот список:

// Символ	   Описание
//   \n	      Перевод строки
//   \r	      В текстовых файлах Windows для перевода строки используется комбинация символов \r\n, а на других ОС это
//             просто \n. Это так по историческим причинам, ПО под Windows обычно понимает и просто \n.
//  \', \"	   Кавычки
//   \\	      Обратный слеш
//   \t	      Знак табуляции
// \b, \f, \v	Backspace, Form Feed и Vertical Tab — оставлены для обратной совместимости, сейчас не используются.

// Как вы можете видеть, все спецсимволы начинаются с обратного слеша, \ — так называемого «символа экранирования».
// Он также используется, если необходимо вставить в строку кавычку.

// К примеру:
console.log('I\'m Marusia!'); // I'm Marusia!
//Здесь перед входящей в строку кавычкой необходимо добавить обратный слеш — \' — иначе она бы обозначала окончание строки.

//Разумеется, требование экранировать относится только к таким же кавычкам, как те, в которые заключена строка. Так что
// мы можем применить и более элегантное решение, использовав для этой строки двойные или обратные кавычки:

console.log(`I'm Marusia!`); // I'm Marusia!

// Заметим, что обратный слеш \ служит лишь для корректного прочтения строки интерпретатором, но он не записывается в
// строку после её прочтения. Когда строка сохраняется в оперативную память, в неё не добавляется символ \. Вы можете явно видеть это в выводах console.log в примерах выше.

// Но что, если нам надо добавить в строку собственно сам обратный слеш: \ ? Это можно сделать, добавив перед ним… ещё один обратный слеш!

console.log(`The backslash: \\`); // The backslash: \

//====================================================================================================================//

// Длина строки

// Свойство length содержит длину строки:

console.log(`My\n`) // My
console.log(`My`.length) // 2
console.log(`My\n`.length); // 3
// Обратите внимание, \n — это один спецсимвол, поэтому тут всё правильно: длина строки 3.

// length — это свойство
// Бывает так, что люди с практикой в других языках случайно пытаются вызвать его, добавляя круглые скобки: они пишут
// str.length() вместо str.length. Это не работает. Так как str.length — это числовое свойство, а не функция, добавлять скобки не нужно.

//===================================================================================================================//

// Доступ к символам

// Получить символ, который занимает позицию pos, можно с помощью квадратных скобок: [pos]. Также можно использовать
// метод str.at(pos). (Первый символ занимает нулевую позицию):

let str3 = `Hello`;

// получаем первый символ
console.log(str3[0]); // H
console.log(str3.at(0)); // H

// получаем последний символ
console.log(str3[str3.length - 1]); // o
console.log(str3.at(-1));
// Как вы можете видеть, преимущество метода.at(pos) заключается в том, что он допускает отрицательную позицию.Если pos
// – отрицательное число, то отсчет ведется от конца строки.
// Таким образом, .at(-1) означает последний символ, а.at(-2) – тот, что перед ним, и т.д.

// Квадратные скобки всегда возвращают undefined для отрицательных индексов.Например:

let str4 = `Привет`;

console.log(str4[-2]); // undefined
console.log(str4.at(-2)); // е

// Также можно перебрать строку посимвольно, используя for..of:

for (let char of "Класс!") {
	console.log(char); // К, л, а, с, с (char — сначала "К", потом "л", потом "а" и т.д. при этом "с" выводится один раз, т.к. он повторяется подряд)
}

//====================================================================================================================//

// Строки неизменяемы

// Содержимое строки в JavaScript нельзя изменить. Нельзя взять символ посередине и заменить его. Как только строка создана — она такая навсегда.

//Давайте попробуем так сделать, и убедимся, что это не работает:
let str5 = 'Hi';
// str[0] = 'h'; // ошибка
// alert(str[0]); // не работает

// но можно создать новую строку и записать её в ту же самую переменную вместо старой.
let str6 = 'Hi';
console.log(str6);
str6 = 'h' + str6[1]; // заменяем строку
console.log(str6); // hi

//=====================================================================================================================//

// Изменение регистра

// Методы toLowerCase() и toUpperCase() меняют регистр символов:

console.log('Interface'.toUpperCase()); // INTERFACE
console.log('Interface'.toLowerCase()); // interface

// Если мы захотим перевести в нижний регистр какой-то конкретный символ:
console.log('Interface'[0].toLowerCase()); // 'i'

//=====================================================================================================================//

// Поиск подстроки (при поиске регистр имеет значение)

// Существует несколько способов поиска подстроки:

// 1) str.indexOf(substr, pos)
// Первый метод — str.indexOf(substr, pos). Он ищет подстроку substr в строке str, начиная с позиции pos, и возвращает
// позицию, на которой располагается совпадение, либо - 1 при отсутствии совпадений.

// Например:

let str7 = 'Widget with id';

console.log(str7.indexOf('Widget')); // 0, потому что подстрока 'Widget' найдена в начале
console.log(str7.indexOf('widget')); // -1, совпадений нет, поиск чувствителен к регистру
console.log(str7.indexOf("id")); // 1, подстрока "id" найдена на позиции 1 (..idget with id)

// Необязательный второй аргумент позволяет начать поиск с определённой позиции.

// Например, первое вхождение "id" — на позиции 1. Для того, чтобы найти следующее, начнём поиск с позиции 2:
let str8 = 'Widget with id';

console.log(str8.indexOf('id', 2)); // 12
console.log(str8[12]); // i, при этом считаются все символы (с пробелаи и т.д.) начиная с первого (на позиции 0)

//-------------------------------------------------------------------------------------------------------------------//

// Чтобы найти все вхождения подстроки, нужно запустить indexOf в цикле.Каждый раз, получив очередную позицию, начинаем новый поиск со следующей:

let str9 = 'Ослик Иа-Иа посмотрел на виадук';
let target2 = 'Иа'; // цель поиска
let pos2 = 0;

while (true) {
	let foundPos = str9.indexOf(target2, pos2);
	if (foundPos == -1) break;

	console.log(`Найдено тут: ${foundPos}`);
	pos2 = foundPos + 1; // продолжаем со следующей позиции
}

// Тот же алгоритм можно записать и короче:

let str10 = "Ослик Иа-Иа посмотрел на виадук";
let target3 = "Иа";

let pos3 = -1;
while ((pos3 = str10.indexOf(target3, pos3 + 1)) != -1) {
	console.log(pos3);
}


// 2) str.lastIndexOf(substr, position)
// Также есть похожий метод str.lastIndexOf(substr, position), который ищет с конца строки: str к её началу.

//Он используется тогда, когда нужно получить самое последнее вхождение: перед концом строки или начинающееся до(включительно) определённой позиции.

//-------------------------------------------------------------------------------------------------------------------//

// При проверке indexOf в условии if есть небольшое неудобство. Такое условие не будет работать!!!:
let str11 = "Widget with id";

if (str11.indexOf("Widget")) {
	console.log("Совпадение есть"); // не работает
}

// Мы ищем подстроку "Widget", и она здесь есть, прямо на позиции 0. Но alert не показывается, т.к.str.indexOf("Widget") возвращает 0, и if решает, что тест не пройден.

// Поэтому надо делать проверку на - 1:
let str12 = "Widget with id";

if (str12.indexOf("Widget") != -1) {
	console.log("проверка indexOf в условии if теперь работает"); // теперь работает
}

//===================================================================================================================//

// includes, startsWith, endsWith

// Более современный метод str.includes(substr, pos) возвращает true, если в строке str есть подстрока substr, либо false, если нет.
// Это — правильный выбор, если нам необходимо проверить, есть ли совпадение, но позиция не нужна:

console.log("Widget with id".includes("Widget")); // true
console.log("Hello".includes("Bye")); // false

// Необязательный второй аргумент str.includes позволяет начать поиск с определённой позиции:
console.log("Midget".includes("id")); // true
console.log("Midget".includes("id", 3)); // false, т.к. поиск начат с позиции 3

// Методы str.startsWith и str.endsWith проверяют, соответственно, начинается ли и заканчивается ли строка определённой строкой:
console.log("Widget".startsWith("Wid")); // true, "Wid" — начало "Widget"
console.log("Widget".endsWith("get")); // true, "get" — окончание "Widget"

//---------------------------------------------------------------------------------------------------------------------//

// Получение подстроки

// В JavaScript есть 3 метода для получения подстроки: substring, substr и slice.

// 1) str.slice(start, end)
// Возвращает часть строки: str от start до (не включая) end.

//Например:

let str13 = "stringify";
// 'strin', символы от 0 до 5 (не включая 5)
console.log(str13.slice(0, 5));

// 's', от 0 до 1, не включая 1, т.е. только один символ на позиции 0
console.log(str13.slice(0, 1));


// Если аргумент end отсутствует, slice возвращает символы до конца строки:
let str14 = "stringify";
console.log(str14.slice(2)); // ringify, с позиции 2 и до конца

// Также для start/end можно задавать отрицательные значения. Это означает, что позиция определена как заданное количество символов с конца строки:
let str15 = "stringify";

// начинаем с позиции 4 справа, а заканчиваем на позиции 1 справа
console.log(str15.slice(-4, -1)); // gif

//-------------------------------------------------------------------------------------------------------------------//

// Давайте подытожим, как работают эти методы, чтобы не запутаться:

//     метод	                          выбирает… 	                        отрицательные значения

// slice(start, end)	       от start до end (не включая end)	     можно передавать отрицательные значения

// substring(start, end)    между start и end (можно задавать start больше end)
//	                                                               отрицательные значения равнозначны 0

// substr(start, length)	 length символов, начиная от start	     значение start может быть отрицательным

// Какой метод выбрать?

// Все эти методы эффективно выполняют задачу. Формально у метода substr есть небольшой недостаток: он описан не в
// собственно спецификации JavaScript, а в приложении к ней — Annex B. Это приложение описывает возможности языка для
//использования в браузерах, существующие в основном по историческим причинам. Таким образом, в другом окружении,
// отличном от браузера, он может не поддерживаться. Однако на практике он работает везде.

// Из двух других вариантов, slice более гибок, он поддерживает отрицательные аргументы, и его короче писать. Так что, в принципе, можно запомнить только его

//--------------------------------------------------------------------------------------------------------------------//

// Сравнение строк

// Как мы знаем из главы: Операторы сравнения, строки сравниваются посимвольно в алфавитном порядке.

// Тем не менее, есть некоторые нюансы.

// -Строчные буквы больше заглавных:

console.log('a' > 'Z'); // true
// -Буквы, имеющие диакритические знаки, идут «не по порядку»:

console.log('Österreich' > 'Zealand'); // true

// Это может привести к своеобразным результатам при сортировке названий стран: нормально было бы ожидать, что Zealand будет после Österreich в списке.


// Чтобы разобраться, что происходит, давайте ознакомимся с внутренним представлением строк в JavaScript.

// Строки кодируются в UTF-16. Таким образом, у любого символа есть соответствующий код. Есть специальные методы,
//позволяющие получить символ по его коду и наоборот.

// 1) str.codePointAt(pos)
// Возвращает код для символа, находящегося на позиции pos в строке str:

// одна и та же буква в нижнем и верхнем регистре
// будет иметь разные коды
console.log("z".codePointAt(0)); // 122
console.log("Z".codePointAt(0)); // 90


// 2) String.fromCodePoint(code)
// Возвращает символ по его коду: code

console.log(String.fromCodePoint(90)); // Z

// Давайте сделаем строку, содержащую символы с кодами от 65 до 220 — это латиница и ещё некоторые распространённые символы:
let str16 = '';

for (let i = 65; i <= 220; i++) {
	str16 += String.fromCodePoint(i);
}
console.log(str16); // ABCDEFGHIJKLMNOPQRSTUVWXYZ[\]^_`abcdefghijklmnopqrstuvwxyz{|}~ ¡¢
// £¤¥¦§¨©ª«¬­®¯°±²³´µ¶·¸¹º»¼½¾¿ÀÁÂÃÄÅÆÇÈÉÊËÌÍÎÏÐÑÒÓÔÕÖ×ØÙÚÛÜ
// Как видите, сначала идут заглавные буквы, затем несколько спецсимволов, затем строчные и Ö ближе к концу вывода.

// Теперь очевидно, почему a > Z.
// (Символы сравниваются по их кодам. Больший код — больший символ. Код a (97) больше кода Z (90))

// Все строчные буквы идут после заглавных, так как их коды больше.

//Некоторые буквы, такие как Ö, вообще находятся вне основного алфавита.У этой буквы код больше, чем у любой буквы от a до z.

//--------------------------------------------------------------------------------------------------------------------//

// Правильное сравнение

//«Правильный» алгоритм сравнения строк сложнее, чем может показаться, так как разные языки используют разные алфавиты.
// Поэтому браузеру нужно знать, какой язык использовать для сравнения.

// К счастью, все современные браузеры (для IE10− нужна дополнительная библиотека Intl.JS) поддерживают стандарт ECMA 402, обеспечивающий правильное сравнение строк на разных языках с учётом их правил.


//Для этого есть соответствующий метод: localeCompare(str2)

// Вызов str.localeCompare(str2) возвращает число, которое показывает, какая строка больше(str или str1) в соответствии с правилами языка:
// -Отрицательное число, если str меньше str2.
// -Положительное число, если str больше str2.
// 0, если строки равны.

// Например:
console.log('Österreich'.localeCompare('Zealand')); // -1

// У этого метода есть два дополнительных аргумента, которые указаны в документации.Первый позволяет указать язык(по
// умолчанию берётся из окружения) — от него зависит порядок букв.Второй — определить дополнительные правила, такие как
// чувствительность к регистру, а также следует ли учитывать различия между "a" и "á" * /