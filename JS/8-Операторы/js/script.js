// Оператор - это символ, благодаря которому могут производиться различные виды вычислений, сравнений или присваиваний с
// участием одного или нескольких значений


// 1-ая группа операторов: базовая (математическая)

// +(сложение), -(вычитание), *(умножение), /(деление), %(взятие остатка от деления), **(возведение в степень)
let a = 11 % 3;
console.log(`результат взятия остатка от деления: ${a}`) // вернёт 2
// Проверка: 11=3*3(не полное частное от деления) + 2(остаток от деления)

a = 2 ** 3;
console.log(`результат возведения в степень: ${a}`); // вернёт 8
// Проверка: 2*2*2 = 8

// 2-ая группа операторов: сравнения
// 3-я группа операторов: логические


// Операнд (аргументы)- это то к чему применяется оператор (представляет собой некоторую величину, обрабатываемую в
// программе) Операнды могут относиться к любому типу данных (пример: строки, числа, переменные, константы и др.)


// В зависимости от применения операторы бывают 2-х типов:

// 1-ый тип: унарный (применяются к одному операнду):
let j = 3;
j = -j; // здесь с помощью унарного оператора: -(вычитание) изменили знак на противоположный операнду: j

// 2-ой тип: бинарный (применяюются к двум операндам)
let x, y;
let coord = x - y; // здесь тот же оператор -(вычитание) является бинарным, т.к. применяется к двум операндам: x и y

//--------------------------------------------------------------------------------------------------------------------//


// СПЕЦИАЛЛЬНЫЕ ВОЗМОЖНОСТИ ОПЕРАТОРОВ

// применение операторов сложения к строкам:

let resultOne = 'Фрилансер' + ' ' + 'по' + ' ' + 'жизни';
console.log(resultOne);

// если хотя бы один операнд в выражении будет строкой, то конечный результат тоже будет строкой:
let resultTwo = 58 + 'фрилансер';
console.log(resultTwo); // ввернёт: 58фрилансер
console.log(typeof resultTwo); // вернёт string

let resultThree = 2 + '2';
console.log(resultThree); // ввернёт: 22
console.log(typeof resultThree); // вернёт string

// операции до сложения со строкой выполняются как обычно
let resultFour = 200 - 50 + "процентов";
console.log(resultFour); // вернёт: 150процентов 
console.log(typeof resultFour); // вернёт: string

// другие арифметические операторы работают только с числами (преобразовывают все операнды в числа)

let c = "25" - 5;
console.log(c); // вернёт: 20
console.log(typeof c); // вернёт: number

let d = 10 * "8";
console.log(d); // вернёт: 80
console.log(typeof d); // вернёт: number

// не допустимая операция
let e = 10 * "фрилансер";
console.log(e); // вернёт: NaN
console.log(typeof e); // вернёт: number

// применение унарного оператора: +(сложение) со строками:

let i = +'123';
console.log(i); // вернёт число: 123 (т.е. происходит преобразование строки в число)
console.log(typeof i); // вернёт: number

let num1 = '25';
let num2 = '100';
console.log(num1 + num2);  // вернёт: строку 25100

console.log(+num1 + +num2);  // вернёт: число: 125

// более длинная запись предыдущего выражения
console.log(Number(num1) + Number(num2));  // вернёт: число 125

//===================================================================================================================//

// ПРИОРИТЕТ ОПЕРАТОРОВ

// 1) умножение и деление выполнится раньше чем сложение и вычитание
// 2) у скобок самый большой приоритет (т.е. сначала происходит вычисление в скобках)
// 3) если у операторов одинаковый приоритет, то действия будут выполняться по порядку (слева на право)
let k = 3 - 1 + 5;
console.log(k); // вернёт: 7
// 4) оператор =(присваивания) отрабатывает в самом конце

// имеется возможность:

// присваивания по цепочке:
let m, n;
let l = m = n = 1 + 4; // сначала выполнится выражение сложения и затем резулльтат присвоится всем переменным
console.log(l); // вернёт: 5
console.log(m); // вернёт: 5
console.log(n); // вернёт: 5

// Сокращённая запись вычислений с присваиванием

// запись
let users1 = 500;
users1 = users1 + 5;
users1 = users1 * 2;
// можно записать так:
let users2 = 500;
users2 += 5;
users2 *= 2;
// имеем
console.log(users1 === users2); // вернёт true
console.log(users1); // вернёт 1010
console.log(users2); // вернёт 1010

// приоритет сокращённоq записи такойже как у оператора присваивания (выполнится в конце)
let users = 5;
users *= 18 + 2; // выполнится сначала сложение, а потом умножение и присваивание
console.log(users); // вернёт: 100

//-------------------------------------------------------------------------------------------------------------------//

// Инкремент(++) и декремент(--) (увеличиает и уменьшает число на 1-цу)

let operator = 0;

// постфиксная форма:
operator++;
operator--;

let newOp = operator++;
console.log(newOp); // вернёт 0, т.к. сначала произойдёт присвоение переменной: newOp текущего значения переменной:
// operator и только потом увеличение переменной: operator на единицу 

// префиксная форма:
++operator;
--operator;

console.log(operator) // вернёт 1
let newOp2 = ++operator;
console.log(newOp2); // вернёт 2, т.к. сначала произойдёт увеличение переменной: operator на единицу, потом  её присвоение переменной: newOp2

//===================================================================================================================//

// 2-ая группа операторов: сравнения (возвращают логический тип данных: true или false)

// больше: >
// меньше: <
// больше или равно: >=
// меньше или равно: <=
// равно: ==
// не равно: !=
// строгое равно: ===
// строгое не равно: !==

console.log(2 > 1); // вернёт true

// результат можно присвоить:
let res = 1 > 2;
console.log(res); // вернёт false

// Сравнение строк:

//Чтобы определить, что одна строка больше другой, JavaScript использует «алфавитный» или «лексикографический» порядок
// Другими словами, строки сравниваются посимвольно (Используется кодировка Unicode, а не настоящий алфавит)

// в JavaScript имеет значение регистр символов. Заглавная буква "A" не равна строчной "a" Строчная "a" больше заглавной
// буквы "A", потому что строчные буквы имеют больший код во внутренней таблице кодирования, которую использует JavaScript (Unicode)

/*
 Алгоритм сравнения двух строк довольно прост:

1.Сначала сравниваются первые символы строк.
2.Если первый символ первой строки больше (меньше), чем первый символ второй, то первая строка больше (меньше) второй. Сравнение завершено.
3.Если первые символы равны, то таким же образом сравниваются уже вторые символы строк.
Сравнение продолжается, пока не закончится одна из строк.
4.Если обе строки заканчиваются одновременно, то они равны. Иначе, большей считается более длинная строка.

В примерах выше сравнение 'a' > 'А' завершится на первом шаге, тогда как строки 'Коты' и 'Кода' будут сравниваться посимвольно:
К равна К.
о равна о.
т больше, чем д. На этом сравнение заканчивается. Первая строка больше 
*/

//--------------------------------------------------------------------------------------------------------------------//

// Сравнение разных типов:

// При сравнении значений разных типов JavaScript приводит каждое из них к числу:
console.log('2' > 1); // true, строка '2' становится числом 2
console.log('01' == 1); // true, строка '01' становится числом 1

// Логическое значение true становится 1, а false = 0.
console.log(true == 1); // true
console.log(false == 0); // true

// операнды разных типов преобразуются оператором == к числу. В итоге, и пустая строка, и false становятся нулём


// ОПЕРАТОР СТРОГОГО РАВЕНСТВА / НЕРАВЕНСТВА === проверяет равенство / неравенство без приведения

//--------------------------------------------------------------------------------------------------------------------//

// Сравнение с null и undefined

// При строгом равенстве === эти значения различны, так как различны их типы:
console.log(null === undefined); // false

// При нестрогом равенстве == эти значения равны друг другу и не равны никаким другим значениям. Это специальное правило языка:
console.log(null == undefined); // true

// При использовании математических операторов и других операторов сравнения < > <= >= значения null/undefined
// преобразуются к числам: null становится 0, а undefined – NaN

// Странный результат сравнения null и 0
console.log(null > 0);  // (1) false, т.к. сравнения преобразуют null в число, рассматривая его как 0

console.log(null == 0); // (2) false, т.к. для нестрогого равенства == значений undefined и null действует особое 
// правило: эти значения ни к чему не приводятся, они равны друг другу и не равны ничему другому

console.log(null >= 0); // (3) true, т.к. сравнения преобразуют null в число, рассматривая его как 0

//---------------------------------------------------------------------------------------------------------------------//

// Значение undefined несравнимо с другими значениями:

console.log(undefined > 0); // false (1)
console.log(undefined < 0); // false (2)
console.log(undefined == 0); // false (3)

/* Почему же сравнение undefined с нулём всегда ложно?

На это есть следующие причины:

Сравнения (1) и (2) возвращают false, потому что undefined преобразуется в NaN, а NaN – это специальное числовое значение, которое возвращает false при любых сравнениях.
Нестрогое равенство (3) возвращает false, потому что undefined равно только null, undefined и ничему больше */

//--------------------------------------------------------------------------------------------------------------------//

// Итого:

/*
1) Операторы сравнения возвращают значения логического типа.
2) Строки сравниваются посимвольно в лексикографическом порядке.
3) Значения разных типов при сравнении приводятся к числу. Исключением является сравнение с помощью операторов строгого равенства/неравенства.
4) Значения null и undefined равны == друг другу и не равны любому другому значению.
5) Будьте осторожны при использовании операторов сравнений вроде > и < с переменными, которые могут принимать значения null/undefined. Хорошей идеей будет сделать отдельную проверку на null/undefined
 */

//====================================================================================================================//

// 3-я группа операторов: логические

// || (ИЛИ) находит первое истинное значение

/* 
Оператор || выполняет следующие действия:

-Вычисляет операнды слева направо.
-Каждый операнд конвертирует в логическое значение. Если результат true, останавливается и возвращает исходное значение этого операнда.
-Если все операнды являются ложными (false), возвращает последний из них

Значение возвращается в исходном виде, без преобразования.
(Другими словами, цепочка ИЛИ || возвращает первое истинное значение или последнее, если такое значение не найдено)
 */

console.log(true || true);   // вернёт true в первом случае
console.log(false || true);  // вернёт true во втором случае
console.log(true || false);  // вернёт сразу true 
console.log(false || false); // т.к. все операнды ложные вернёт значение последнего: false


// Если значение не логического типа, то оно к нему приводится в целях вычислений Например, число 1 будет воспринято как true, а 0 – как false:

console.log(true || 0); // вернёт true
console.log(false || 'фрилансер'); // вернёт фрилансер (т.к. первое значение оказалось ложное)
console.log(null || 2); // вернёт 2 (первое истинное значение)
console.log(null || 0 || 3); // вернёт 3 (первое истинное значение)
console.log(undefined || null || '' || 0); // вернёт 0 (поскольку все ложно, возвращается последнее значение)

//------------------------------------------------------------------------------------------------------------------//

// ВАРИАНТЫ ПРИМЕНЕНИЯ ОПЕРАТОРА ||

// Получение первого истинного значения из списка переменных или выражений и присваивание другой переменной:
let currentUser = '';
let defaultUser = "John";
let name = currentUser || defaultUser || "unnamed"; // выбирается 2-ой вариант"John" т.к. является первым истинным значением
console.log(name);

// Сокращённое вычисление (условие):
/* 
Операндами могут быть как отдельные значения, так и произвольные выражения. ИЛИ || вычисляет их слева направо. Вычисление останавливается при достижении первого истинного значения. Этот процесс называется «сокращённым вычислением», поскольку второй операнд вычисляется только в том случае, если первого недостаточно для вычисления всего выражения 
*/
let admins = 3;
let usersNew = 5;
admins > usersNew || admins++;
console.log(admins); // вернёт 4, т.к. первый операнд(условие): ложное, выполнится 2-ая часть

//===================================================================================================================//

// && (и) находит первое ложное значение и возвращает true, если оба аргумента истинны, а иначе – false:

console.log(true && true);   // вернёт true
console.log(false && true);  // вернёт false
console.log(true && false);  // вернёт false
console.log(false && false); // вернёт false

/* 
При нескольких подряд операторах И(&&), оператор && выполняет следующие действия:

-Вычисляет операнды слева направо.
=Каждый операнд преобразует в логическое значение. Если результат false, останавливается и возвращает исходное значение этого операнда.
-Если все операнды были истинными, возвращается последний.

(Другими словами, И возвращает первое ложное значение. Или последнее, если ничего не найдено)
*/
console.log(5 && 0); // Если первый операнд истинный, И(&&) возвращает второй (т.е. вернёт 0). первый операнд игнорируется
console.log(null && 5); // Если первый операнд ложный, И(&&) возвращает его (т.е. вернёт null). Второй операнд игнорируется

// Можно передать несколько значений подряд
console.log(1 && 2 && false && 3); // возвратится первое «ложное» значение, на котором остановились вычисления (т.е. вернёт: false)

console.log(1 && 2 && 3); // Когда все значения верны, возвращается последнее т.е. 3

/* 
Приоритет оператора И (&&) больше, чем ИЛИ (||), так что он выполняется раньше.

Таким образом, код a && b || c && d по существу такой же, 
как если бы выражения && были в круглых скобках: (a && b) || (c && d)
*/
console.log(5 && 0 || 2 && 7); // вернёт 7;

//-------------------------------------------------------------------------------------------------------------------//

// Как и оператор ИЛИ ||, И && иногда может заменять if

let x1 = 1;
(x1 > 0) && console.log('число больше нуля'); // Действие в правой части && выполнится только в том случае, если до него
// дойдут вычисления. То есть, console.log сработает, если в левой части (x1 > 0) будет true

// получился аналог:
let x2 = 2;
if (x2 > 0) {
	console.log('число больше нуля');
}

//====================================================================================================================//

// (НЕ)!

// Оператор принимает один аргумент и выполняет следующие действия:

// -Сначала приводит аргумент к логическому типу true/false.
// -Затем возвращает противоположное значение.

console.log(!true); // вернёт false
console.log(!0); // вернёт true


// В частности, двойное НЕ !! используют для преобразования значений к логическому типу:

console.log(!!"non-empty string"); // вернёт true
console.log(!!null); // вернёт false
// То есть первое НЕ преобразует значение в логическое значение и возвращает обратное, а второе НЕ снова инвертирует
// его. В конце мы имеем простое преобразование значения в логическое.

//Есть немного более подробный способ сделать то же самое – встроенная функция Boolean:
console.log(Boolean("non-empty string")); // вернёт true
console.log(Boolean(null)); // вернёт false

// Приоритет НЕ ! является наивысшим из всех логических операторов, поэтому он всегда выполняется первым, перед && или ||.

//===================================================================================================================//

// Оператор нулевого слияния (??)

/*
Так как он обрабатывает null и undefined одинаковым образом, то для этой статьи мы введём специальный термин. Для краткости будем говорить, что значение «определено», если оно не равняется ни null, ни undefined

Результат выражения a ?? b будет следующим:
если a определено, то a,
если a не определено, то b.
(Иначе говоря, оператор ?? возвращает первый аргумент, если он не null/undefined, иначе второй)
*/

// можно записать последовательность из операторов ??, чтобы получить первое значение из списка, которое не является null/undefined:
let firstName = null;
let lastName = null;
let nickName = "Суперкодер";

// показывает первое значение, которое определено:
console.log(firstName ?? lastName ?? nickName ?? "Аноним"); // вернёт: Суперкодер

// Важное различие между || и && заключается в том, что:

//               || возвращает первое истинное значение.
//\              ?? возвращает первое определённое значение.

let height = 0;
console.log(height || 100); // вернёт 100
console.log(height ?? 100); // вернёт 0


// Приоритет оператора ?? такой же, как и у ||. Они оба равны

/* 
Это означает, что, как и ||, оператор нулевого слияния ?? вычисляется до = и ?, но после большинства других операций, таких как +, *.

Так что, в выражениях такого вида понадобятся скобки:
*/
let height1 = null;
let width = 20;

// важно: используйте круглые скобки
let area = (height1 ?? 100) * (width ?? 50);

console.log(area); // вернёт 2000

// По соображениям безопасности JavaScript запрещает использование оператора ?? вместе с && и ||, если приоритет явно не
// указан при помощи круглых скобок:
let x3 = (1 && null) ?? 333;
console.log(1 && null); // здесь вернёт null, поэтому
console.log(x3); // вернёт 333