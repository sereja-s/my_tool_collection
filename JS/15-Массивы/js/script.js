// Массивы

// Объекты позволяют хранить данные со строковыми ключами. Это замечательно.

// Но довольно часто мы понимаем, что нам необходима упорядоченная коллекция данных, в которой присутствуют 1-й, 2-й,
// 3-й элементы и т.д. Например, она понадобится нам для хранения списка чего-либо: пользователей, товаров, элементов HTML и т.д.

// В этом случае использовать объект неудобно, так как он не предоставляет методов управления порядком элементов. Мы не
// можем вставить новое свойство «между» уже существующими. Объекты просто не предназначены для этих целей.

// Для хранения упорядоченных коллекций существует особая структура данных, которая называется массив, Array

// Объявление

//Существует два варианта синтаксиса для создания пустого массива:
// let arr = new Array();
// let arr = [];
// Практически всегда используется второй вариант синтаксиса.

// В квадратных скобках мы можем указать значения элементов массива (в строку или столбик), через запятую:
let fruits = ["Яблоко", "Апельсин", "Слива"];

// Элементы массива нумеруются, начиная с нуля.

// Мы можем получить элемент(значение), обратившись к переменной которой присвоен данный массив и указав его позицию(ключ), значение которого хотим получить в квадратных скобках:
console.log(fruits[0]); // Яблоко
console.log(fruits[1]); // Апельсин
console.log(fruits[2]); // Слива

// Мы можем заменить элемент:
fruits[2] = 'Груша'; // теперь ["Яблоко", "Апельсин", "Груша"]

// …Или добавить новый к существующему массиву:
fruits[3] = 'Лимон'; // теперь ["Яблоко", "Апельсин", "Груша", "Лимон"]

// Общее число элементов массива содержится в его свойстве length:
console.log(fruits.length); // 4

// Вывести массив целиком можно при помощи console.log и др.
console.log(fruits); // Яблоко, Апельсин, Слива

//--------------------------------------------------------------------------------------------------------------------//

// В массиве могут храниться элементы любого типа.

// Например:
// разные типы значений
let arr = [
	'Яблоко', // строка
	{
		name: 'Света', // объект со своими элементами
		age: 35
	},
	true, // булевый тип
	function () { console.log('Привет, я Света!'); } // функция
];

// выведем массив в консоль
console.log(arr);

// получить элемент с индексом 1 (объект) и затем показать его свойство
console.log(arr[1].name); // Света

// получить элемент с индексом 3 (функция) и вызвать(выполнить) её. Для этого после обращения к элементу массива, являющегося функцией, ставим круглые скобки
arr[3](); // привет


// Висячая запятая
// Список элементов массива, как и список свойств объекта, может оканчиваться запятой:
let fruits2 = [
	"Яблоко",
	"Апельсин",
	"Слива",
];
// «Висячая запятая» упрощает процесс добавления / удаления элементов, так как все строки становятся идентичными

//-------------------------------------------------------------------------------------------------------------------//

// Многомерные массивы

//Массивы могут содержать элементы, которые тоже являются массивами. Это можно использовать для создания многомерных массивов, например, для хранения матриц:

let matrix = [
	[1, 2, 3],
	[4, 5, 6],
	[7, 8, 9]
];

// получим конкретное значение из многомерного массива (в 1-ых квадратных скобках указываем позицию(ключ) элемента,
// который тоже является массивом и затем во 2-х квадратных скобках указываем позицию(ключ) в нём требуемого нам элемента)
console.log(matrix[1][1]); // 5, центральный элемент

//--------------------------------------------------------------------------------------------------------------------//

// Длина массива Свойство: length

// Свойство length автоматически обновляется при изменении массива. Если быть точными, это не количество элементов
// массива, а наибольший цифровой индекс плюс один.

// Например, единственный элемент, имеющий большой индекс, даёт большую длину:

let fruits3 = [];
fruits3[123] = "Яблоко";
console.log(fruits3.length); // 124
// Обратите внимание, что обычно мы не используем массивы таким образом.

// Ещё один интересный факт о свойстве length – его можно перезаписать.

// Если мы вручную увеличим его, ничего интересного не произойдёт. Зато, если мы уменьшим его, массив станет короче.
// Этот процесс необратим, как мы можем понять из примера:

let arr2 = [1, 2, 3, 4, 5];

arr2.length = 2; // укорачиваем до двух элементов
console.log(arr2); // [1, 2]

arr2.length = 5; // возвращаем length как было
console.log(arr2[3]); // undefined: значения не восстановились

// Таким образом, самый простой способ очистить массив – это arr.length = 0;.

//-------------------------------------------------------------------------------------------------------------------//

// Внутреннее устройство массива

// Массив – это особый подвид объектов. Квадратные скобки, используемые для того, чтобы получить доступ к свойству
// arr[0] – это по сути обычный синтаксис доступа по ключу, как obj[key], где в роли obj у нас arr, а в качестве ключа – числовой индекс.

// Массивы расширяют объекты, так как предусматривают специальные методы для работы с упорядоченными коллекциями данных,
// а также свойство length. Но в основе всё равно лежит объект.

// Следует помнить, что в JavaScript существует 8 основных типов данных. Массив является объектом и, следовательно, ведёт себя как объект.

// Например, копируется по ссылке:
let fruits4 = ["Банан"]

let arr3 = fruits4; // копируется по ссылке (две переменные ссылаются на один и тот же массив)

console.log(arr3 === fruits4); // true

arr3.push("Груша"); // массив меняется по ссылке добавили элемент

console.log(fruits4); // Банан, Груша - теперь два элемента

// …Но то, что действительно делает массивы особенными – это их внутреннее представление. Движок JavaScript старается
// хранить элементы массива в непрерывной области памяти, один за другим Существуют и другие способы оптимизации,
// благодаря которым массивы работают очень быстро.

// Но все они утратят эффективность, если мы перестанем работать с массивом как с «упорядоченной коллекцией данных» и начнём использовать его как обычный объект:

// Это возможно, потому что в основе массива лежит объект. Мы можем присвоить ему любые свойства.
// Но движок поймёт, что мы работаем с массивом, как с обычным объектом. Способы оптимизации, используемые для массивов,
// в этом случае не подходят, поэтому они будут отключены и никакой выгоды не принесут.

// Варианты неправильного применения массива:

// -Добавление нечислового свойства, например: arr.test = 5.
// -Создание «дыр», например: добавление arr[0], затем arr[1000] (между ними ничего нет).
// -Заполнение массива в обратном порядке, например: arr[1000], arr[999] и т.д.

// Массив следует считать особой структурой, позволяющей работать с упорядоченными данными. Для этого массивы
// предоставляют специальные методы. Массивы тщательно настроены в движках JavaScript для работы с однотипными
// упорядоченными данными, поэтому, пожалуйста, используйте их именно в таких случаях. Если вам нужны произвольные
// ключи, вполне возможно, лучше подойдёт обычный объект {}.

//--------------------------------------------------------------------------------------------------------------------//

// Получение последних элементов при помощи «at»

// Допустим, нам нужен последний элемент массива.

// Некоторые языки программирования позволяют использовать отрицательные индексы для той же цели, как-то так: fruits[-1].
// Однако, в JavaScript такая запись не сработает. Её результатом будет undefined, поскольку индекс в квадратных скобках понимается буквально.

// Мы можем явно вычислить индекс последнего элемента, а затем получить к нему доступ вот так: fruits[fruits.length - 1].

let fruits5 = ["Apple", "Orange", "Plum"];
console.log(fruits5[fruits5.length - 1]); // Plum
// Немного громоздко, не так ли? Нам нужно дважды написать имя переменной.

// К счастью, есть более короткий синтаксис: fruits5.at (-1) (то же самое, что и fruits5[fruits5.length-1])
console.log(fruits5.at(-1)); // Plum

// Другими словами, arr.at(i):
// -это ровно то же самое, что и arr[i], если i >= 0.
// -для отрицательных значений i, он отступает от конца массива